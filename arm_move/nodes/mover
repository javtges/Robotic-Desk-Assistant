#!/usr/bin/env python
'''
Publishes a Twist to cmd_vel at a fixed frequency, using the python package to make the turtle travel in a figure-eight trajectory.

PUBLISHERS:
  + cmd_vel (geometry_msgs/Twist) at a fixed frequency, causing the turtlebot to follow the desired open-loop trajectory.

BROADCASTERS:
  + A static transfrom /tf from world to odom.

SUBSCRIPTIONS:
  + /turtle1/pose (Pose) ~ continually publishes the pose of the turtle in XY coordinates, theta, angular and linear velocities.

SERVICES:
  + /pause ~ stops the turtle in its place, logs the time it was paused at.
  + /resume ~ resumes the turtle's movement, subtracts the time paused from the calculated time so that the turtle resumes in its current place.

PARAMETERS:
  + ~pub_freq - the frequency that Twist is published to cmd_vel
  + W - the width of the figure-eight
  + H - the height of the figure-eight
  + T - the period of the turtle's travel

'''

import sys
import copy

import rospy
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg
from std_msgs.msg import String
from std_srvs.srv import Empty, EmptyResponse
from moveit_commander.conversions import pose_to_list
from interbotix_xs_modules.arm import InterbotixManipulatorXS
from arm_move.srv import step, follow


class Mover:
    
    def __init__(self):

        self.__reset = rospy.Service("reset", Empty, self.reset)
        self.__step = rospy.Service("step", step, self.step_cb)
        self.__follow = rospy.Service("follow", follow, self.follow)

        rospy.set_param('waypoints', [])

        moveit_commander.roscpp_initialize(sys.argv)
        rospy.init_node("mover", anonymous=True)
        print("made it to init node??")
        self.group_name = "interbotix_arm"
        self.gripper_name = "interbotix_gripper"

        self.move_group = moveit_commander.MoveGroupCommander(self.group_name)
        self.grip_group = moveit_commander.MoveGroupCommander(self.gripper_name)

        self.scene = moveit_commander.PlanningSceneInterface()
        self.robot = moveit_commander.RobotCommander()
        print("it made it here")
        rospy.sleep(5)

        self.add_table()


        #print(get_jacobian_matrix([3,3,3,3]))

    def gotoJointTest(self):
        move_group = self.move_group #not required?

        joint_goal = move_group.get_current_joint_values()

    def wait_for_state_update(self, box_is_known=False, box_is_attached=False, timeout=4):
        
        box_name = "box"
        scene = self.scene

        start = rospy.get_time()
        seconds = rospy.get_time()
        while (seconds - start < timeout) and not rospy.is_shutdown():
            # Test if the box is in attached objects
            attached_objects = scene.get_attached_objects([box_name])
            is_attached = len(attached_objects.keys()) > 0
            # Test if the box is in the scene.
            # Note that attaching the box will remove it from known_objects
            is_known = box_name in scene.get_known_object_names()
            # Test if we are in the expected state
            if (box_is_attached == is_attached) and (box_is_known == is_known):
                return True
            # Sleep so that we give other threads time on the processor
            rospy.sleep(0.1)
            seconds = rospy.get_time()
        # If we exited the while loop without returning then we timed out
        return False

    def move_to_position(self, x, y, z, g):
        xyz = [x,y,z]
        rospy.logerr([x,y,z])
        self.move_group.set_position_target(xyz)
        ecv, traj, time, err = self.move_group.plan()
        rospy.logerr(err)

        if err.val == 1:
            self.move_group.execute(traj, wait='true')
            self.move_group.go(wait='true')
            self.move_group.stop()

            if g == True:
                self.grip_group.set_named_target("Closed")

            elif g == False:
                self.grip_group.set_named_target("Open")
        
            self.grip_group.go(wait='true')
            self.grip_group.stop()

        return err.val

    def reset(self, req):
        '''
        Takes a position and orientation of the realsense box and creates/moves the realsense box to the appropriate location
        Moves the robot to its predefined Home position
        Takes a parameter that determines if the waypoints are cleared or not - ??????????
        '''
        self.add_box()
        self.move_group.set_named_target("Home")
        self.move_group.go()
        #ToDo: edit add_box to take positional arguments
        #ToDo: edit to have option to clear waypoint list in parameter server
        rospy.logerr(self.move_group.get_current_pose())

        return EmptyResponse()

    def step_cb(self, req):
        '''
        Moves the robot to a user-specified position
        Returns MoveItErrorCode
        If success, adds it to parameter server
        '''
        x = req.point.x
        y = req.point.y
        z = req.point.z

        err = self.move_to_position(x,y,z,req.gripper_pose)

        robot_state = [x,y,z,req.gripper_pose]
        rospy.logerr(err)
        if err == 1:
            # Add the waypoint to the parameter server
            list_of_waypoints = rospy.get_param('waypoints')
            list_of_waypoints.append(robot_state)
            rospy.set_param('waypoints', list_of_waypoints)
        
        return err

    def follow(self, req):
        '''
        Has the robot move to each waypoint, in sequence
        Has an option that determines if the cycle should be repeated or not
        '''
        list_of_waypoints = rospy.get_param('waypoints')
        rospy.logerr(list_of_waypoints)
        repeat = req.repeat
        num_wps = len(list_of_waypoints)

        if repeat == True:
            while True:
                for wp in range(num_wps):
                    x = list_of_waypoints[wp][0]
                    y = list_of_waypoints[wp][1]
                    z = list_of_waypoints[wp][2]
                    g = list_of_waypoints[wp][3]
                    self.move_to_position(x,y,z,g)
                    rospy.sleep(0.5)

        if repeat == False:
            for wp in range(num_wps):
                    x = list_of_waypoints[wp][0]
                    y = list_of_waypoints[wp][1]
                    z = list_of_waypoints[wp][2]
                    g = list_of_waypoints[wp][3]
                    self.move_to_position(x,y,z,g)
                    rospy.sleep(0.5)

        return repeat

    def add_box(self, timeout=0):

        box_pose = geometry_msgs.msg.PoseStamped()
        box_pose.header.frame_id = "world"
        box_pose.pose.orientation.w = 1.0
        box_pose.pose.position.z = 0.02
        box_pose.pose.position.y = 0.05  
        box_pose.pose.position.x = 0.2 
        
        box_name = "box"
        self.scene.add_box(box_name, box_pose, size=(0.14, 0.09, 0.05))
        #return self.wate_for_state_update(box_is_known=True, timeout = timeout)

    def add_table(self, timeout=0):

        box_pose = geometry_msgs.msg.PoseStamped()
        box_pose.header.frame_id = "world"
        box_pose.pose.orientation.w = 1.0
        box_pose.pose.position.z = -0.5
        box_pose.pose.position.y = 0  
        box_pose.pose.position.x = 0 
        
        
        box_name = "table"
        self.scene.add_box(box_name, box_pose, size=(1, 1, 1))
        #return self.wate_for_state_update(box_is_known=True, timeout = timeout)

    def move_home(self):
        self.move_group.set_named_target("Home")
        go = self.move_group.go(wait = 'true')
        self.move_group.stop()
        return


if __name__ == '__main__':
    ''' The main() function. '''
    Mover()
    rospy.spin()