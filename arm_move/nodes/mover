#!/usr/bin/env python
'''
Publishes a Twist to cmd_vel at a fixed frequency, using the python package to make the turtle travel in a figure-eight trajectory.

PUBLISHERS:
  + cmd_vel (geometry_msgs/Twist) at a fixed frequency, causing the turtlebot to follow the desired open-loop trajectory.

BROADCASTERS:
  + A static transfrom /tf from world to odom.

SUBSCRIPTIONS:
  + /turtle1/pose (Pose) ~ continually publishes the pose of the turtle in XY coordinates, theta, angular and linear velocities.

SERVICES:
  + /pause ~ stops the turtle in its place, logs the time it was paused at.
  + /resume ~ resumes the turtle's movement, subtracts the time paused from the calculated time so that the turtle resumes in its current place.

PARAMETERS:
  + ~pub_freq - the frequency that Twist is published to cmd_vel
  + W - the width of the figure-eight
  + H - the height of the figure-eight
  + T - the period of the turtle's travel

'''

import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg
from std_msgs.msg import String
from std_srvs.srv import Empty, EmptyResponse
from moveit_commander.conversions import pose_to_list
from interbotix_xs_modules.arm import InterbotixManipulatorXS


class Mover:
    
    def __init__(self):

        moveit_commander.roscpp_initialize(sys.argv)
        rospy.init_node("mover", anonymous=True)
        self.scene = moveit_commander.PlanningSceneInterface()
        self.group_name = "interbotix_arm"
        self.move_group = moveit_commander.MoveGroupCommander(group_name)

        # We can get the name of the reference frame for this robot:
        planning_frame = move_group.get_planning_frame()
        print("============ Planning frame: %s" % planning_frame)

        # We can also print the name of the end-effector link for this group:
        eef_link = move_group.get_end_effector_link()
        print("============ End effector link: %s" % eef_link)

        # We can get a list of all the groups in the robot:
        group_names = robot.get_group_names()
        print("============ Available Planning Groups:", robot.get_group_names())

        # Sometimes for debugging it is useful to print the entire state of the
        # robot:
        # print("============ Printing robot state")
        # print(robot.get_current_state())
        # print("")
        self.add_box()

        print(get_jacobian_matrix([3,3,3,3]))

    def gotoJointTest(self):
        move_group = self.move_group #not required?

        joint_goal = move_group.get_current_joint_values()


    def add_box(self, timeout=4):

        box_pose = geometry_msgs.msg.PoseStamped()
        box_pose.header.frame_id = "world"
        box_pose.pose.orientation.w = 1.0
        box_pose.pose.position.z = 0.11  # above the panda_hand frame
        box_name = "box"
        self.scene.add_box(self.box_name, box_pose, size=(0.075, 0.075, 0.075))

    def move_home(self):
        self.move_group.set_named_target("Home")
        go = self.move_group.go(wait = 'true')
        self.move_group.stop()
        return


if __name__ == '__main__':
    ''' The main() function. '''
    Mover()
    rospy.spin()